from __future__ import annotations

import base64
import csv
import dataclasses
import os
import random
import subprocess
import time
from pathlib import Path

from evaluation.util import generate_distribution


def generate_username() -> str:
    """
    Randomly sample from https://github.com/danielmiessler/SecLists/blob/master/Usernames/xato-net-10-million-usernames.txt
    """
    usernames_path = Path(__file__).parent.parent / "helper_data" / "usernames_100k.txt"
    with usernames_path.open() as f:
        base_username = random.choice(f.readlines())[:-1]
    return base_username


def generate_keepass_pwd() -> str:
    """Uses keepass-cli to generate a password using default settings.

    Must have KPCLIPATH envvar set"""
    kpcli_path = os.getenv("KPCLIPATH")
    assert kpcli_path is not None, "KPCLIPATH envvar must be set"
    p = subprocess.run([kpcli_path, "generate"], capture_output=True)
    return p.stdout.decode("utf-8")[:-1]


def generate_list_password() -> str:
    """
    Randomly sample from https://github.com/danielmiessler/SecLists/blob/master/Passwords/xato-net-10-million-passwords-100000.txt
    """
    passwords_path = Path(__file__).parent.parent / "helper_data" / "passwords_10k.txt"
    with passwords_path.open() as f:
        return random.choice(f.readlines())[:-1]


def generate_url() -> str:
    # Top 100k from https://tranco-list.eu/list/6699X/1000000 downloaded 10/29/24
    usernames_path = Path(__file__).parent.parent / "helper_data" / "websites_100k.csv"
    with usernames_path.open() as f:
        base_url = random.choice(f.readlines()).split(",")[1][:-1]
    # We add a random number to end of username to simulate slightly different usernames across accounts
    return base_url


def generate_base64_seconds() -> str:
    """Random time in the last year. Code partially generated by copilot"""
    # Get the current time in seconds since the epoch
    current_time_seconds = int(time.time() - random.randint(0, int(3.15e7)))

    # Convert the current time to bytes
    time_bytes = str(current_time_seconds).encode("utf-8")

    # Encode the bytes to base64
    base64_encoded_time = base64.b64encode(time_bytes)

    return base64_encoded_time.decode("utf-8")


@dataclasses.dataclass
class KeepassCSVRow:
    account_name: str
    version: int  # version is used to record history of an entry (e.g. password for an entry changes)
    group: str
    username: str
    password: str
    url: str

    @classmethod
    def generate_row(cls, group: str, username: str = None, random_password: bool = True) -> KeepassCSVRow:
        username = generate_username() if username is None else username
        password = generate_keepass_pwd() if random_password else generate_list_password()
        url = generate_url()
        return cls(
            account_name=f"{url} {username}",
            version=0,
            group=group,
            password=password,
            username=username,
            url=url,
        )


def generate_keepass_csv(n: int, m: int, dist: str, random_passwords: bool, output_path: Path) -> None:
    """Given some parameters, generate a CSV containing Keepass password data.

    Args:
    -----
    n: Number of Keeshare groups
    m: Number of Entries across entire database
    dist: Distribution of the number of entries for a group ("even", "random" or "long_tail")
    random_passwords: Whether keepass should generate passwords or they should be sampled from a list of common passwords
    output_path: Output path for generated CSV file

    """
    group_num_entries = generate_distribution(n, m, dist)

    rows = []
    for i, num_entries in enumerate(sorted(group_num_entries, reverse=True)):
        if i == 0:
            # Generate root group first
            group = "Root"
        else:
            # Assume group is shared with a different user
            group = f"Shared with {generate_username()}"

        username = generate_username()
        for j in range(num_entries):
            # We add a random number to end of username to simulate slightly different usernames across accounts
            entry = KeepassCSVRow.generate_row(group, username + str(random.randint(0, 9)), random_passwords)
            rows.append(entry)
            # Generate password change history (assuming 1 past versions of entry)
            new_password = generate_keepass_pwd() if random_passwords else generate_list_password()
            new_version_entry = dataclasses.replace(entry, version=1, password=new_password)
            rows.append(new_version_entry)

    columns = [field.name for field in dataclasses.fields(KeepassCSVRow)]
    output = [columns]
    for row in rows:
        output_row = [getattr(row, c) for c in columns]
        output.append(output_row)

    with output_path.open("w") as f:
        writer = csv.writer(f)
        writer.writerows(output)
