import base64
import copy
import os
import random
import subprocess
import time
import uuid
from pathlib import Path
from string import ascii_lowercase
from xml.etree import ElementTree


def generate_username() -> str:
    return "Bob"


def generate_pwd() -> str:
    """Uses keepass-cli to generate a password using default settings.

    Must have KPCLIPATH envvar set"""
    kpcli_path = os.getenv("KPCLIPATH")
    assert kpcli_path is not None, "KPCLIPATH envvar must be set"
    p = subprocess.run([kpcli_path, "generate"], capture_output=True)
    return p.stdout.decode("utf-8")[:-1]


def generate_url() -> str:
    return "google.com"


def generate_base64_seconds() -> str:
    """Random time in the last year. Code partially generated by copilot"""
    # Get the current time in seconds since the epoch
    current_time_seconds = int(time.time() - random.randint(0, int(3.15e7)))

    # Convert the current time to bytes
    time_bytes = str(current_time_seconds).encode("utf-8")

    # Encode the bytes to base64
    base64_encoded_time = base64.b64encode(time_bytes)

    return base64_encoded_time.decode("utf-8")


def generate_entry(sample_entry: ElementTree.Element) -> ElementTree.Element:
    """Taking as input a sample element generate new values."""
    new_entry = copy.deepcopy(sample_entry)
    new_entry.remove(new_entry.find("History"))
    new_entry.find("UUID").text = str(uuid.uuid4())
    sample_time = generate_base64_seconds()
    for t in ["LastModificationTime", "CreationTime", "LastAccessTime", "ExpiryTime", "LocationChanged"]:
        new_entry.find(f"Times/{t}").text = sample_time
    for e in new_entry.findall("String"):
        if e.find("Key").text == "Password":
            e.find("Value").text = generate_pwd()
        if e.find("Key").text == "UserName":
            e.find("Value").text = generate_username()
        if e.find("Key").text == "URL":
            e.find("Value").text = generate_url()
        if e.find("Key").text == "Title":
            e.find("Value").text = "".join(random.choice(ascii_lowercase) for _ in range(10))
        if e.find("Key").text == "Notes":
            e.find("Value").text = "".join(random.choice(ascii_lowercase) for _ in range(10))

    hist_entry = copy.deepcopy(new_entry)
    new_history_element = ElementTree.SubElement(new_entry, "History")
    for _ in range(2):
        for e in hist_entry.findall("String"):
            if e.find("Key").text == "otp":
                hist_entry.remove(e)
        hist_entry.find("UUID").text = str(uuid.uuid4())
        new_history_element.append(hist_entry)

    return new_entry


def generate_keepass_xml(n: int, dist: str) -> ElementTree.ElementTree:
    """Given some parameters, generate a Keepass XML file for testing.

    Args:
    -----
    n: Number of Keeshare groups
    D: Distribution of the number of entries for a group

    Returns: An XML ETree for the generated XML file
    """
    if dist == "shallow":
        group_num_entries = [2] * n
    else:
        group_num_entries = [3] * n

    sample_etree = ElementTree.parse(Path(__file__).parent / "data" / "Sample.xml")
    new_etree = copy.deepcopy(sample_etree)
    root_group = new_etree.find("./Root/Group")
    sample_entry = root_group.find("./Entry")
    sample_group = root_group.find("./Group")

    for i, num_entries in enumerate(sorted(group_num_entries, reverse=True)):
        if i == 0:
            # Generate root group first
            for e in root_group.findall("./Entry"):
                root_group.remove(e)
            for g in root_group.findall("./Group"):
                root_group.remove(g)
            for _ in range(num_entries):
                root_group.append(generate_entry(sample_entry))
        else:
            new_share_group = copy.deepcopy(sample_group)
            new_share_group.find("UUID").text = str(uuid.uuid4())
            new_share_group.find("Name").text = "".join(random.choice(ascii_lowercase) for _ in range(10))
            for e in new_share_group.findall("./Entry"):
                new_share_group.remove(e)
            for _ in range(num_entries):
                new_share_group.append(generate_entry(sample_entry))
            root_group.append(new_share_group)

    return new_etree
